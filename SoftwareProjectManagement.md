# SOFTWARE PROJECT MANAGEMENT

An introductory Project Management resource guide For Business Technology Enthuthiasts and other Technical People in the Software Business


## TABLE OF CONTENTS

- [INTRODUCTION](#introduction)
- [A BRIEF EMPHASIS ON PROJECT MANAGEMENT](#a-brief-emphasis-on-project-management)
  - [What is Project Management](#what-is-project-management)
- [WHAT IS A SOFTWARE PROJECT](#what-is-a-software-project)
  - [Types of software-related projects](#types-of-software-related-projects)
- [WHY SOFTWARE PROJECTS SOMETIMES DELAY](#why-software-projects-sometimes-delay)
- [WHAT IS SOFTWARE PROJECT MANAGEMENT](#what-is-software-project-management)
  - [What is Software Lifecycle Model](#what-is-software-lifecycle-model)
  - [The Different Software Development Life Cycle models](#the-different-software-development-life-cycle-models)
    - [Classical Waterfall Model](#classical-waterfall-model)
    - [Iterative Waterfall Model](#iterative-waterfall-model)
    - [Prototyping Model](#prototyping-model)
    - [Evolutionary Model](#evolutionary-model)
    - [Spiral Model](#spiral-model)
  - [Comparison of different life-cycle models](#comparison-of-different-life-cycle-models)
  - [## The Software development lifecycle (SDLC)](#the-software-development-lifecycle-sdlc)
- [CONCLUSION](#conclusion)
- [GLOSSARY](#glossary)
- [KEYWORDS](#keywords)

## INTRODUCTION

The nature of specific Software characteristics in its application and production differentiate it from other domains, which call for specific management techniques. And as software engineering matured as a discipline, more interest grew in the systematic integration of management activities in the software production process. Software development and project management thus started to be integrated more tightly. 

Software project management integrate project management techniques into software development. The need for such integration has its root in the 1960s, in the days of the “software crisis,” when practitioners recognized the increasing complexity of delivering software products meeting the specifications. 

Because software development is a complex and tasking activity carried out by competent people often referred to as Programmers, Coders or Software Engineers/Developers, good software is characterized by functional and non-functional requirements among other specified client needs from which an analysis/planning is made to ascertain a scope.

Software Products have life-cycles, called _software lifecycles_ that involve engineering phases, consisting of concept creation, requirements specification, design, implementation, integration, testing, and deployment for which the appropriate Software Developement Lifecycle is defined with the help of [Software lifecycle models](#what-is-software-lifecycle-model). As a software evolves through the various stages of it's lifecycle, each _software lifecycle model_ provides specific guidance to the sequencing and repetition of life cycle activities to deliver a high-quality software product.

The Software Development Life Cycle (SDLC) is the management of a software lifecycle through effective planning, creating, testing, deploying and post improvement (where required) of a software product. It consists of stages _(Analysis/ Planning, Design, Development/Implementation, Testing, Deployment, and then maintenance)_ which are sometimes unchangeable at certain levels depending on the industry, client requirements and team, therefore it's success depends on the people, process, and product for which _Software Project Management_ is the answer.

Project management in a software engineering environment is unique because of the technical aspects of a software project. While software engineers are generally accountable for the technical aspects of a project, project managers are accountable for organizational aspects. 

Software project managers share many of the goals of project managers in other domains, namely, ensuring an appropriate quality of the end product, while, at the same time, keeping under control all the other project variables, like time and costs and in some cases a project manager can be the Software Developer on a project.

-----------
This Documentation resource like all my other documentations is made up of research study notes based curated informational resources from books, articles and other useful online content with the intention of informing myself and making this rich material readily available for anyone else having a hard time finding this kind of information.

---------------

## A BRIEF EMPHASIS ON PROJECT MANAGEMENT

Even though Project Management has been practiced since early civilization, It was in the 1950s that organizations started to systematically apply project management tools and techniques to complex projects. It developed from several fields of application including construction, engineering, and defense activity, with **Henry Gantt _(called the father of planning and control techniques who is famous for his use of the Gantt chart as a project management tool)_**; and **Henri Fayol _(for his creation of the five management functions which form the foundation of the body of knowledge associated with project and program management)_** considered the two forefathers of Project Management.  

The 1950s marked the beginning of the modern Project Management era. Project management became recognized as a distinct discipline arising from the management discipline. 

In order to understand, appreciate and excel at Software Project Management as a software engineer or software developer, you first need to have a good grasp of Project management in generally because 

- You might end up working under a project manager on a project team either developing a software product or otherwise which requires you to know some basic project management that can help you understand what to do, what they’re doing (e.g., using a RACI matrix to define who on the team does what) and what they’re trying to tell you about the project (e.g., implications of the burn down chart analysis). 

- Or you might need to self-manage (e.g., within an organization that has a flattened hierarchy or within an Agile team). 

- Alternatively you could also end up becoming a project manager yourself because your employer asks you to fill the role, a specific project requires it or simply out of sheer interest as a professional growth milestone.

### What is Project Management?

Project Management is the process of planning and executing a project while balancing the time, cost, and scope constraints. Time, cost, and scope are the three limiting factors that govern project execution broadly known as the triple constraint. 

Even though Project Management is a leadership role to some extent, there is nothing like a perfect Project Manager, one simply endeavors to be good, effective and efficient. 

Project Managers are not wizards and do not carry magic wands, rather their job is to lead a team of individuals usually a project team though a journey of achieving some very clear objectives quickly and efficiently by applying formal processes, methods, tools and techniques to a related set of tasks or activities in order to complete them within a specific time and budget.

The successful delivery of Software Products requires subjecting Software Projects to a budget, schedule and constraints often set by the organisation developing the software thus, the need for Project Management which in this case is concerned with all the activities involved in ensuring that software is delivered on time and on schedule, in accordance with the set requirements and deliverables.

## WHAT IS A SOFTWARE PROJECT? 

When we think about software projects, probably the first thing that comes to mind is developing applications and While this is true in many cases, software-related projects take different forms. Even when the main goal is developing a system, coding is just one of the required activities.

Some of the essential software projects management areas for handling the project goals to consider include:

-  scope management, which includes all the activities to ensure that a project delivers according to the goals it sets. 
- time management, which defines a schedule for a project and delivers according to the schedule. 
-  cost management, which defines a budget and controls spending during a project. 
- change and configuration management, which help manage changes in a project, while maintaining a coherent view on its outputs. These processes interact with all software development activities and also influence goals, schedules, and costs. 
- risk management, the set of activities to effectively manage menaces and opportunities. And similar to change and configuration management, risk management runs throughout a project, reducing the influence of unexpected events. 
- quality management, the set of activities to ensure that a project defines quality goals and delivers accordingly the goals. 
- human resource management 
- stakeholder management 

Some software project management Practitioners will go as as distinguishing between traditional and agile management depending on the software project needs or client requirements and expectations.

Software development projects range from the very small to the very large and encompass a wide range of complexity, starting from software developed by a small team in their spare time and ending with projects lasting several years and involving the work of many people. 

Like all Projects, software projects are like wild animals when they start was a lot of room for anything and everything going wrong. It’s the leader’s job in this case a project manager, or sometimes team/tech lead to control that chaos and funnel it in the right direction to success. They can’t do it on their own, though. It’s the entire tech/development team's job to keep that in mind and provide the project manger with as much help as they can, in addition to writing among other software project tasks. 

The concept of what it means for a software development project to succeed varies according to the context with the activities required or beneficial to develop successful software varying from project to project. Some projects might allow a more informal approach, while others are better served by a very structured and controlled process. 

### Types of software-related projects

**Application Development**

Application development might not be the only type of software-related project, but it is probably one that is great fun. The goal in this kind of project is building an application and providing the additional services and outputs to support it. 
From the project management point of view, we can distinguish the following types of applications: 

- One-offs or bespoke systems that are software systems specifically created for a customer. A bespoke system often implements a specific need of a cus- tomer, although in some cases the customer base of the final product could be large. Some examples of bespoke systems include a luggage tracking software, a compiler for a specific hardware platform, and a system to monitor a fleet of trucks. For bespoke systems, the specification of the application to develop (more in general of the project goals) will be driven and have to be agreed with the customer. The ownership and the source code of the final product might also be handed over to the customer. This kind of projects offers an opportunity for the supplier to enter a new market or establish a long-term relationship with a new customer. Consider, for instance, activities related to the long-term maintenance of a complex software system. The uniqueness and novelty of the product also constitute the main risk both for the customer and the supplier. 

- Off-the-shelf applications are software systems implementing a function which is useful to many different users. It is the software we buy from mar- ketplaces or stores and it is the equivalent of the Ford Model-T: one size fits all.∗ The goals and functions of the applications, in this case, come from the company developing the system, which sometimes conducts user surveys, to better understand needs and features that are most useful. Larger organizations might involve different departments in the specification of the software, mak- ing the activity similar to the previous case. A marketing department might play the role of the customer, defining the requirements, while an engineer- ing department plays the role of the supplier and delivers the solution. The main characteristic is that the system is the same for each user and that the company developing the system sets the roadmap, choosing when to upgrade, what functions to add, and when to do maintenance.

- Finally, a customized off-the-shelf application sits somewhere between the two other types of applications. They are systems that are developed similar to off-the-shelf applications. However, they need to (or can) be customized to fit the customer needs. An example of a customized off-the-shelf applica- tion is an enterprise resource planning (ERP) system. An ERP system helps plan the resources of an organization and automate information management. While the engine of many ERPs is generic (and developed as an off-the-shelf application), many other characteristics (modules to use, what data has to be stored, how information flows) need to be customized for each client. 

**Process and Systems Reengineering Services**

Process and Systems Reengineering Services are projects related to improving the efficiency of an organization, by changing the way in which they conduct their operational work. These projects often accompany the introduction of one or more systems. In many cases, the system being introduced is an ERP. According to the project goals and size of the client, these projects might be significant and complex. 

Consider the example of a multinational company revising its customer help- desk to improve quality and responsiveness. This project requires to understand how the organization currently works, what are the bottlenecks, and thus the possible interventions. These could include modifications to the current practices, training, and perhaps the introduction of a customer relationship management system to support the new processes. 

**System Integration Services**

System integration services are projects and services related to automating the information flow among the different and independent systems used by an organiza- tion. The goals are to improve the efficiency of work and to reduce data duplication and errors. The approach is chosen when migrating to a new system is impractical or too costly. 
Two types of integration are possible, vertical or horizontal. The first refers to the integration of different systems performing similar functions (e.g., putting together data about customers kept by different departments of a multinational company). The latter refers to automating or improving business functions (e.g., automating the flow of orders from marketing to production). 
System integration services are more common in large organizations, which have a long history of system automation, or organizations in which departments have large autonomy. In these cases, in fact, different departments might automate similar functions without paying too much attention to data integration. Over time, the portfolio of applications grows and data coherence problems start to pop up. For instance, the IT systems of a company might still grant access to its premises to a person whose contract has expired, if the contracts and accesses are managed by two independent systems and someone forgot to manually update the data. 
According to the project scope, these kinds of projects might be large, like in the case of reengineering services, or very focused, like it could be the case of a project to interface two systems. In the first case, the project requires an analysis of the business procedures and of the IT infrastructure. 

**Other Types of Software Projects**

Consulting services might be asked to gain know-how, which is outside a com- pany’s core competence. An example of consulting services is the evaluation of the reliability of a software system conducted using very specific techniques, which could not be part of the core business of a company. Another very common request is the assessment of the state of the art in a particular sector. 
Installation and training services are services related to the installation of spe- cific software systems (also in the open source domain) and/or training in the use of specific technologies or systems. 

**Legacy software products**

A legacy system as any software system that is hard to maintain. The typical problems associated with legacy systems are poor documentation, unstructured (spaghetti code with ugly control structure), and lack of personnel knowledgeable in the product. Many of the legacy systems were developed long time back. But, it is possible that a recently developed system having poor design and documentation can be considered to be a legacy system. 

The activities involved in a software maintenance project are not unique and depend on several factors such as: 
• the extent of modification to the product required the resources available to the maintenance team
• the conditions of the existing product (e.g., how structured it is, how well documented it 
is, etc.)
• the expected project risks, etc. 

When the changes needed to a software product are minor and straightforward, the code can be directly modified and the changes appropriately reflected in all the documents. But more elaborate activities are required when the required changes are not so trivial. Usually, for complex maintenance projects for legacy systems, the software process can be represented by a reverse engineering cycle followed by a forward engineering cycle with an emphasis on as much reuse as possible from the existing code and other documents. 


## WHY SOFTWARE PROJECTS SOMETIMES DELAY

Have you ever thoroughly closed a project on your own? I’m not asking you if you’ve coded everything you had to code. That’s a given. I’m asking you if you did everything else needed to close a software project. 

There is a “funny because it’s true” type of rule in the industry that says, “The first 90% of the project is finished within 10% of the time, while the last 10% of the project requires 90% of the time.” Read that again and let it sink in. If you’ve done all your coding and you’ve managed to close all your tasks, why do you think your leader isn’t calling it a day already? What else is there to do? 

There are many reasons why projects can take longer than expected or be hard to close, and while those reasons aren’t necessarily related to you, the developer, it’s important for you to understand the type of issues your leader has to deal with. 

Let’s take a look at some of the most common reasons for delays, so you know how to identify them and can raise your hand as a warning, in case your leader hasn’t picked up on them yet: 

 The dreaded scope creep—All projects start with a somewhat defined backlog of work—the list of items that need to be completed for the project to be deemed “done.” This list is first created at a high level and then detailed as you go along (for agile methodologies), or it’s thoroughly detailed before writing the first line of code (in more traditional, waterfall-like methodologies). The scope creep happens when new features or changes are added to the original backlog. If more work is added, for whatever reason, more time needs to be estimated for the completion of the project. If instead tasks are added but the original estimates are not revised, you’ll reach the point in time you had originally esti- mated you’d be done, but you’ll still have a lot more to do. 
Adding work in the middle of a project development cycle is not unheard of. In fact, many agile methodologies embrace that practice, but they also cover the effect of that new workload on overall estimates. So if you see this happen- ing to your project, and no one is raising their hands to talk about the effect it’ll have on the overall delivery date, you might want to ask about it. In the worst- case scenario, your leader has already considered it; in the best case, you’re bringing up a huge point and everyone will thank you for it. 

 Leaving unknowns for last—I’ve already discussed assumptions several times in this book, so by now you should know that they are great for making estimations, but they don’t always reflect reality. If you have many assumptions at the start of your project, leaving them for the end is not a great idea. You might end up real- izing that most of them were wrong and that you need to adjust your plan and perhaps even your product. Instead try to validate your assumptions as soon as possible, and correct any affected estimates sooner rather than later. As a responsible developer, if you notice that you’re working on a feature that’s based on assumptions, you might want to raise your hand and speak up. Let everyone know that while you are perfectly capable of working on the feature, there is a huge risk of needing to rework the feature once the assumption is verified. 

 Having people work on multiple projects at once—This is not unheard of, believe it or not, especially in consulting companies. These companies will try to maximize the profit they get from a developer by committing them to multiple projects, sometimes even having them working at 100% in all of them, which makes no sense (how can you be working full time on more than one thing at the same time?). The problem with this is that these projects tend to be independent of each other, have different priorities and, in some cases, their managers don’t even know about the existence of the other. This puts the developer in the mid- dle, having to deal with potentially conflicting priorities and having to decide which one takes precedence over the other, and they may end up picking the less relevant project or the wrong task to focus on. This responsibility should not be on the developer. If you happen to find yourself in this situation, make sure there is someone out there—someone who is outside of these projects—that knows about you and is capable of helping you make the difficult calls between conflict- ing priorities. That person can be a mentor, a manager, or perhaps even a senior manager who can interact and lead the managers pulling you in different direc- tions. Each company will have a different hierarchical structure, so make sure you understand who above you can help you resolve problems like these. 

 Reworking features due to poor planning—This can be seen as a specialized version of the assumptions problem. When a project starts and its features aren’t prop- erly defined with the level of detail required, developers will tend to make assumptions on their own. And we all know what happens with assumptions. In this case, the problem is even worse, because these assumptions will probably go unnoticed by everyone (even the developer who made them). By the time you’re finishing the project and closing the features, these unconscious assump- tions will come and bite you, causing you to reevaluate your life choices along with the decisions you made back then. Do not make assumptions if you can avoid them, and if you do, document them somewhere, ideally on the task- tracking software you’re using. That way, you are notifying your leader, so they can validate the assumptions in time. Additionally, you’re leaving a paper trail about what these assumptions were, so that when the time comes and the fea- ture doesn’t work as expected, everyone knows about them. 

## WHAT IS SOFTWARE PROJECT MANAGEMENT?

A Software Project in most cases is just like a project-- a temporary, one-time endeavor undertaken to solve a problem or take advantage of an opportunity, with a budget or a set of scarce resources that must be managed and some kind of timeframe/constraint for completion or operation to me customer (either internal or external to the organization ) needs.

Before one can undertake a project to solve a problem one must first understand the problem. Not only understand the details of the problem but also understand who has the problem and the context and environment that must be taken into consideration in addressing the problem.

A key practice in getting things clear is to look at the problem from the customers and users perspectives.

- What is important to the customer?
- How will the user actually be using the system.
- What does the world look like from their perspective?
- What do they value and what is the solution worth?
- Engineers tend to focus on features while customers are interested in benefits; how will this help them solve their problems.

One way to get this perspective is to spend time with the customers and users and enter into a dialog with them. If project managers run projects in isolation, these projects will never serve the needs of the organisation for which it is undertaken. Project managers thus should consider projects within the greater organizational context and take a holistic view of a project. Systems thinking describes this holistic view of carrying out projects

When a software product is being developed, there must be a clear understanding among the software project team members on when and what to do, otherwise there will be chaos leading to project failure. 

A typical Software Development process from beginning to end will often looks like;-

- **Idea Conception:** The initial phase where the concept for a software project is conceived and outlined.
- **Requirements Gathering:** Involves collecting and documenting the functional and non-functional requirements for the software.
- **Design and Planning:** Creating the architecture and planning the development process based on the gathered requirements.
- **Software Development:** The actual coding and implementation of the software based on the design and plan.
- **Continuous Integration and Testing:** Regularly integrating code changes and performing automated testing to ensure software quality.
- **Deployment to Staging:** Deploying the software to a staging environment for further testing and validation.
- **User Acceptance Testing (UAT):** Allowing end-users to test the software to ensure it meets their expectations and requirements.
- **Deployment to Production:** Releasing the software to the live production environment for public use.
- **Monitoring and Incident Response:** Continuous monitoring of the production environment, with immediate response to any incidents or issues.
- **Post-Production Iteration and Scaling:** Making improvements to the software based on user feedback and scaling the system to handle increased load or demand.

Software Project Management is the planning, managing and tracking of software development projects. It is a holistic approach to managing software projects throughout a software lifecycle with a project management mindset which focuses on the management of project information, resourcing, costing and budgeting among other key activities to deliver on-time, on-budget and in-scope projects.

While the deliverable might differ from other projects that produce tangible deliverables, the processes are basically the same as the management of any other type of project.

In order to effectively manage Software Projects from beginning to end Software Project teams often have to manage it's software lifecycle using the **Software Development Life Cycle (SDLC)** whose phases _(Requirements, Design, Implementation, Testing, Maintainance)_, are inherited from and thus losely overlap with the traditional **_Project Management Life Cycle** phases(_Initiation, Planning, Execution, Monitoring and Control, Closing_).

There are different ways to travel through the SDLC stages and these patterns are called _**software lifecycle models**_,  _**software process models**_ or simply **process models**.

### What is Software Lifecycle Model?

A _**software lifecycle model**_ (also called process model) is a descriptive and diagrammatic representation of the software life cycle, mapping the different activities performed on a software product from start to end. It essentially captures and represents all the required activities and the order in which they are to be undertaken to make a software product transit through its life cycle phases.

Software development teams are required to identify suitable lifecycle models based on the project needs, specified requirements or client expectations for a particular software project undertaking and adhere to them for the duration of the entire project. 

Choosing and using a particular lifecycle model helps software project teams ensure systematic and disciplined development of quality software products that meeting client expectations and industry standards without which, software project managers can face challenges executing and monitoring the progress of a software project. 

### The Different Software Development Life Cycle models

Over the years many life cycle models have been proposed and used with each model presenting some advantages as well as some disadvantages.
A few important and commonly used life cycle models include:

#### **Classical Waterfall Model**

Though the classical waterfall model is elegant and intuitively obvious, it is not a practical model in the sense that it cannot be used in actual software development projects. Thus, this model can be considered to be a theoretical way of developing software. But all other life cycle models are essentially derived from the classical waterfall model.

The classical waterfall model is an idealistic one since it assumes that no development error is ever committed by the engineers during any of the life cycle phases. However, in practical development environments, the engineers do commit a large number of errors in almost every phase of the life cycle. The source of the defects can be many: oversight, wrong assumptions, use of inappropriate technology, communication gap among the project engineers, etc. These defects usually get detected much later in the life cycle. 

For example, a design defect might go unnoticed till we reach the coding or testing phase. Once a defect is detected, the engineers need to go back to the phase where the defect had occurred and redo some of the work done during that phase and the subsequent phases to correct the defect and its effect on the later phases. Therefore, in any practical software development work, it is not possible to strictly follow the classical waterfall model.

#### **Iterative Waterfall Model**

The iterative waterfall model was conceptualized mainly to overcome the major shortcomings of the classical waterfall model. The advantage of this model is that there is a working model of the system at a very early stage of development which makes it easier to find functional or design flaws. Finding issues at an early stage of development enables to take corrective measures in a limited budget. 

In the same breath, this SDLC model is mostly applicable only to large and bulky software development projects. This is because it is hard to break a small software system into further small serviceable increments/modules.

#### **Prototyping Model**

A prototyping model can be used when technical solutions are unclear to the development team. A developed prototype can help engineers to critically examine the technical issues associated with the product development. Often, major design decisions depend on issues like the response time of a hardware controller, or the efficiency of a sorting algorithm, etc. In such circumstances, a prototype may be the best or the only way to resolve the technical issues.

A prototype is a toy implementation of the system that usually exhibits limited functional capabilities, low reliability, and inefficient performance compared to the actual software built using several shortcuts.

The shortcuts might involve using inefficient, inaccurate, or dummy functions. The shortcut implementation of a function, for example, may produce the desired results by using a table look-up instead of performing the actual computations. A prototype usually turns out to be a very crude version of the actual system.

There are several uses for prototypes such as illustrating input data formats, messages, reports, and the interactive dialogues to a customer which can be a valuable mechanism for gaining better understanding of the customer’s needs or gaining customer buy-in prior to actual development of the software product e.g;-

- how the screens might look like.
- how the user interface would behave.
- how the system would produce outputs.

Developing prototypes is also important because it's not easy to get the perfect software product in the first attempt thus Many engineering teams and business analysts often advocate and plan for the possibility of throwing away the first version on the way to developing a good final software product. In most cases the experience gained when developing the prototype can be and is often used to develop the final software product that is shipped to the client.

In other cases, a prototype of the actual product maybe preferred where user requirements are not complete or technical issues are not clear.

#### **Evolutionary Model**

It is also called successive versions model or incremental model. At first, a simple working model is built. Subsequently it undergoes functional improvements & we keep on adding new functions till the desired system is built. 

Applications:

- Large projects where you can easily find modules for incremental implementation. Often used when the customer wants to start using the core features rather than waiting for the full software. 
- Also used in object oriented software development because the system can be easily portioned into units in terms of objects. 

Advantages:

- User gets a chance to experiment partially developed system 
- Reduce the error because the core modules get tested thoroughly. 

Disadvantages:

- It is difficult to divide the problem into several versions that would be acceptable to the customer which can be incrementally implemented & delivered. 

#### **Spiral Model**

 Each loop of the spiral represents a phase of the software process, and each phase in this model is split into four sectors (or quadrants).

The following activities are carried out during each phase of a spiral model. 

**First quadrant (Objective Setting)**

- During the first quadrant, it is needed to identify the objectives of the phase.
- Examine the risks associated with these objectives. 

**Second Quadrant (Risk Assessment and Reduction)**

- A detailed analysis is carried out for each identified project risk. 
- Steps are taken to reduce the risks. For example, if there is a risk that the requirements are inappropriate, a prototype system may be developed. 

**Third Quadrant (Development and Validation)** 

- Develop and validate the next level of the product after resolving the identified risks. 

**Fourth Quadrant (Review and Planning)**

- Review the results achieved so far with the customer and plan the next iteration around the spiral. 
- Progressively more complete version of the software gets built with each iteration around the spiral. 

**Circumstances to use spiral model **

The spiral model is called a meta model since it encompasses all other life cycle models. Risk handling is inherently built into this model. The spiral model is suitable for development of technically challenging software products that are prone to several kinds of risks. However, this model is much more complex than the other models – this is probably a factor deterring its use in ordinary projects. 

### **Comparison of different life-cycle models**
 
The classical waterfall model can be considered as the basic model and all other life cycle models as embellishments of this model. However, the classical waterfall model cannot be used in practical development projects, since this model supports no mechanism to handle the errors committed during any of the phases. 

This problem is overcome in the iterative waterfall model. The iterative waterfall model is probably the most widely used software development model evolved so far. This model is simple to understand and use. However this model is suitable only for well-understood problems; it is not suitable for very large projects and for projects that are subject to many risks. 

The prototyping model is suitable for projects for which either the user requirements or the underlying technical aspects are not well understood. This model is especially popular for development of the user-interface part of the projects. 

The evolutionary approach is suitable for large problems which can be decomposed into a set of modules for incremental development and delivery. This model is also widely used for object- oriented development projects. Of course, this model can only be used if the incremental delivery of the system is acceptable to the customer. 

The spiral model is called a meta model since it encompasses all other life cycle models. Risk handling is inherently built into this model. The spiral model is suitable for development of technically challenging software products that are prone to several kinds of risks. However, this model is much more complex than the other models – this is probably a factor deterring its use in ordinary projects. 

The different software life cycle models can be compared from the viewpoint of the customer. Initially, customer confidence in the development team is usually high irrespective of the development model followed. During the lengthy development process, customer confidence normally drops off, as no working product is immediately visible. Developers answer customer queries using technical slang, and delays are announced. This gives rise to customer resentment. On the other hand, an evolutionary approach lets the customer experiment with a working product much earlier than the monolithic approaches. 

Another important advantage of the incremental model is that it reduces the customer’s trauma of getting used to an entirely new system. The gradual introduction of the product via incremental phases provides time to the customer to adjust to the new product. Also, from the customer’s financial viewpoint, incremental development does not require a large upfront capital outlay. The customer can order the incremental versions as and when he can afford them.

## THE SOFTWARE DEVELOMENT LIFE CYCLE (SDLC)

**_Software Development_** being a complex process involving a number of activities like  requirements specification, designing and producing different artifacts, evaluating and testing software products, communication with the customers and end-users, deployment,  conducting UATs, providing maintainence and customer support, monitoring and reporting, cordinating end-user training, planning potential upgrades and negotiating about them with the customers, and much more, Software project managers must exercise control and guidance over the software development team throughout the **_Software Project's Life Cycle_**, to keep everything under control, eliminate delays, stay within the budget, and prevent project runaways, using a **_Software Development Life Cycle (SDLC)_**.

The Software Development Life Cycle (SDLC) is a series of development stages of a software Lifecycle through which a software project is managed from beginning to end. It's a methodology that forms the framework for planning and controlling the creation, testing, monitoring and delivery of a software Product.


One of the primary duties of the Software Project Manager is to ensure that all the Software Development Project activities are organized as a series/phases of actions following a certain predefined process specifying what artifacts should be developed and delivered in each phase, from start and leading up to a desirable end. 

A Software development team, will then conform to the predefined process for that software project thereby complying with an appropriate order of actions led by a Software Project Manager, for whom the process provides means for control and guidance for the team as a whole, while also offering a criteria for tracing and evaluating the project's activities and deliverables. 

Because all Software Projects have some semblance of a Software Development Lifecycle, the basic SDLC phase;-

1. **Requirements:** Defining what the software must do, how well it must do what it will do, and under what limitations or con- straints 
2. **Design:** Defining how the code will be structured and how the user will experience the software 
3. **Implementation:** Coding or otherwise converting the design into a product 
4. **Testing:** Checking that the code was written without fault (verification) and that the software is what the users or client wants (validation) 
5. **Maintenance:** Improving software’s existing functionality 

when broken down, will look somewhat like:

1. **Requirement gathering:**: This is where you listen to your client and understand what they want. 
2. **Defining:**: This is where you and your client settle on the product to be built, based on the requirements you gathered.
3. **Designing:** Before writing any code, you need to have an idea of what you’re going to be building. This phase is not only about UI design, but about overall architecture as well. 
4. **Coding:** Now we’re talking. This is where we write the code that makes every- thing defined so far a reality.
5. **Testing:** This is the validation of the coding work and in fact happens during the Verification and validation of software products or even during software quality assurance. This is where the quality threshold is set, and if your work does not meet that threshold, it won’t move forward. The true test of quality comes from the validation of an objective party: the testing team, sometimes also known as the quality assurance team or the quality control team. 
6. **Deployment:** Here you move the tested work into the hands of the users.
7. **Maintenance:** When your deployed code is no longer going to be heavily changed, you might keep adding to it or fixing small problems, but the overall feature is done. 

depending on the Software Engineer/Developer, Software team, or Software Company.

Because every software project goes through these steps/phases, with different teams utilizing the SDLC differently, it's worth noting that the seven above listed steps are not absolute, and are sometimes even bundled up into fewer steps/phases e.g **_Requirements gathering_** and **_defining_** in one phase like **_Software Requirements Definition_** or **_The Requirements Analysis and Specifications Phase_**, **_Coding_**, **_Testing_** and **_Deployment_** into **_Implementation Phase_**.  

This is why SDLC a cycle and not a straight path from start to finish. 

Let's explore the Software Development Lifecycle in detail.

###Software Requirements Definition (_Software Requirements Gathering and Analysis_)
###Software Design
###SoftwareImplementation
###SoftwareTesting:** Checking that the code was written without fault(verification) and that the software is what the users or client wants (validation) 
###SoftwareDeployment
###SoftwareHandoverPhase
###SoftwareMaintenance

Additionally some Software Teams or Software Companies also conduct Post-Software Project Closure activities like

### SOFTWARE REQUIREMENTS DEFINITION PHASE (_Software Requirements Gathering and Analysis_)


Before the software project team starts developing a software product, it needs to first identify, describe, understand and document the exact requirements of the system to be built from the client in a _scope document_ that can be converted to a detailed _Software Requirement Specification(SRS) document_ using a discipline called [Requirements Engineering]().

Therefore during the **_Software Requirements Definition Phase_**, the Software Project Team with the help of **_Requirements Engineering_** defines what the software must do, how well it must do what it will do under what limitations or constraints. The main output of this activity is one or more artifacts describing the (software) requirements of a proposed system, e.g., a _Software Requirement Specification(SRS) document_ , which loosely defines all the functions a proposed system will implement, the other properties it will have and a _scope document_ the goals of a Software Project.

in this phase, the Software Project Team is trying to understanding basic questions pertaining to the software project like;-

- What problem is the proposed software product solving?!
- What is the current state of the exsisting system? 
- What are all the possible solutions to the problem?
- Why is it important to solve the problem?
- What complexities are likely to arise while solving the problem?
- What are the input-output parameters to the system?
- Are there any system integrations and data interchange formats the proposed software product will have with external/exsisting systems?

The Requirement Engineering process is loosely composed of four steps: 

- **Requirements elicitation** where a list of features of a proposed system are elicited from the client through activities like interviews, workshops, questionaires or analysing existing documents. 
- **Requirements structuring** where the gathered requirements are annotated to make them easier to manage and maintain.
- **User experience design** whose goal is to provide a coherent and satisfying experience on the different artifacts that constitute a software system, including its design, interface, interaction, and manuals. 
- **Requirements validation** where the gathered requirements are analyzed to find inconsistencies, incompleteness and duplicates 

Sometimes even Business Modeling  ***(and in some cases business re-engineering)*** process usually organized in two main steps, the **_“as is” analysis_** and **_“to be” analysis_** is also carried out.

The **_“as is” analysis_** describes the organization before the introduction of a new system and helps the software project team & other project stakeholders understand the current infrastructure and needs. 
 

### SOFTWARE DESIGN PHASE

The Software Design Phase is the stage where the concentration shifts from the _problem domain_ to the _solution domain_ by specifying how to fulfill the requirements mentioned in the Software Requirement Specification(SRS) document using a defined system architecture of the software product to be built(_developed_). 

By transforming the analysis model of the requirements from the **_Software Requirements Definition Phase_** into a design model that can be implemented in a specific hardware and software environment this phase yields a blueprint or more documents which describe, with diagrams and text, the structure of the proposed system to be developed, 

namely: 

- What software components constitute the system, 
- Which function each component implements,
- How the components are interconnected,

which allows software development team to break the complexity of building a system by separating concerns ***(allocating functions to components, and by specifying functions in terms of more elementary and simpler to implement components)***.

**The result can be a design models at aby of these three levels:**

- **Architectural Design:** The architectural design is the highest abstract version of the system. It identifies the software as a system with many components interacting with each other. At this level, the designers get the idea of proposed solution domain.

- **High-level Design:** The high-level design breaks the ‘single entity-multiple component’ concept of architectural design into less-abstracted view of sub-systems and modules and depicts their interaction with each other. High-level design focuses on how the system along with all of its components can be implemented in forms of modules. It recognizes modular structure of each sub-system and their relation and interaction among each other.

- **Detailed Design:** Detailed design deals with the implementation part of what is seen as a system and its sub-systems in the previous two designs. It is more detailed towards modules and their implementations. It defines logical structure of each module and their interfaces to communicate with other modules. 

### Software Design Approaches

Generally software development teams will follow one of two generic approaches for software designing: 

**Top down Design**:

We know that a system is composed of more than one sub-systems and it contains a number of components. Further, these sub-systems and components may have their one set of sub-system and components and creates hierarchical structure in the system. 
Top-down design takes the whole software system as one entity and then decomposes it to achieve more than one sub-system or component based on some characteristics. Each sub- system or component is then treated as a system and decomposed further. This process keeps on running until the lowest level of system in the top-down hierarchy is achieved. 

Top-down design starts with a generalized model of system and keeps on defining the more specific part of it. When all components are composed the whole system comes into existence. 

Top-down design is more suitable when the software solution needs to be designed from scratch and specific details are unknown. 

**Bottom-up Design**:

The bottom up design model starts with most specific and basic components. It proceeds with composing higher level of components by using basic or lower level components. It keeps creating higher level components until the desired system is not evolved as one single component. With each higher level, the amount of abstraction is increased. 

Bottom-up strategy is more suitable when a system needs to be created from some existing system, where the basic primitives can be used in the newer system. 

Both, top-down and bottom-up approaches are not practical individually. Instead, a good combination of both is used.

### Software Design Principles

Software design principles guide developers in creating efficient, scalable, and maintainable software. 

Here's a list of some of the most essential software design principles:

1. **𝗞𝗲𝗲𝗽 𝗜𝘁 𝗦𝗶𝗺𝗽𝗹𝗲, 𝗦𝘁𝘂𝗽𝗶𝗱 (KISS):**emphasises keeping your codebase as simple and clear as possible. 
2. **𝗗𝗼𝗻'𝘁 𝗥𝗲𝗽𝗲𝗮𝘁 𝗬𝗼𝘂𝗿𝘀𝗲𝗹𝗳 (DRY):** emphasisies avoiding duplication in code and try to reuse code instead of copying it where and if necessary, to avoid inconsistencies and bugs in Software.
3. **𝗬𝗔𝗚𝗡𝗜 (You Aren't Gonna Need It):** emphasises avoiding the addition of unnecessary complexity by always and only adding functionality when needed.
4. **SOLID:** is a key set of principles in object-oriented programming that steers developers towards creating maintainable, scalable, and robust software architectures. They were introduced by Robert C. Martin (Uncle Bob), although they were influenced by earlier work from others.
5. **Principle of Least Astonishment/Surprise:** suggests that a solution or approach would not surprise a reasonably knowledgeable person in the subject area when encountered for the first time.
6. **Principle of Modularity:** emphasises designing software as a collection of independent modules to make it easier to understand, maintain, and test.
7. **Principle of Abstraction:** emphasises designing software by hiding the implementation details from the user to make it easier to understand and use.
8. **Principle of Encapsulation:** is all for designing software with the emphasises of hiding the internal state of an object from the outside world making the software more robust and maintainable.
9. **Composition over Inheritance:** whose emphasis is on favoring object composition over class inheritance, as it's more flexible and helps to avoid problems associated with larger inheritance hierarchies.
10. **Principle of Least Knowledge (𝗟𝗮𝘄 𝗼𝗳 𝗗𝗲𝗺𝗲𝘁𝗲𝗿 (LoD)):** emphasises how an object should only communicate with its immediate friends and not know other objects' inner workings. Software should be designed to minimize the amount of knowledge that a module needs about other modules which can help to make the software more modular and flexible.
11. **Principle of Low Coupling & High Cohesion:** where Coupling refers to the degree to which the elements of a module depend on each other and Cohesion refers to the degree to which the elements of a module belong together.

### SOFTWARE IMPLEMENTATION PHASE

Also referred to as the Coding phase or otherwise converting the design into a product, the **_Software Implementation Phase_**, is the process of converting the specified requirements of the proposed system into an actual Software Product to be deployed or the process of integrating the proposed application into an organization's workflow. 

In most business settings, steps like implementing, testing (User acceptance testing) and deployment can happen concurrently or inter-changeably depending on client requirements or team.

The objective of the coding phase is to transform the design of a system or software product into code in a high level language and then to unit test this code to ensure quality, functionality and acceptance among other parameters. The software engineers/developers adhere to standard and well defined coding standard with the main advantages of adhering to a standard style of coding being:

- Promoting good programming practices. 
- Facilitating a code of understanding.
- Giving uniform appearances to the code written by different engineers

Some of the aspects of the Software Implementation Phase that are more closely related to project management include 

- The use of coding standards, which are guidelines describing best practices and the preferred styles to write code. Coding standards are adopted to ensure that the work of different programmers is similarly structured.
- Collection of quality metrics, which allow one to measure the quality of the system to be developed and trends in the development process. 
- Estimation techniques based on software size, and monitoring techniques are some of the activities done here as well. 
- Collection of productivity and size metrics, which allow one to measure the speed at which code is delivered and the amount of work that has been performed. 

Along with the Software product's executable files and source code, teams also develop various kinds of documents such as users’ manual, software requirements specification (SRS) documents, design documents, test documents, installation manual, etc as part of any software engineering process. All these documents are a vital part of good software development practice.

Software Documentation is an important part of the software development process that provides information about the software product. A Well written & maintained documents is a great tool and information repository that can guide a user on;- how to use it, walkthroughs, changelogs, release dates, data dictionaries, terminologies etc, of a software product. 

Different types of software documents can broadly be classified into Internal and External documentation.

Even though, Software Implementation Management processes can slightly differ depending on the vendors delivery processes or client agree needs/requirements a Software Implementation process typically begins with identifying a software for an already specified solution, establishing a budget and choosing a vendor to provide the software solution. The next steps may involve installing the application, migrating data, testing various features, training users as well as other services management activities like issue tracking & technical support until complete handover & sign off is done. 

Companies use software implementation when adopting new applications for project management, supply chain management and enterprise resource planning. The process can also apply when a development team updates an existing application.
 
### SOFTWARE TESTING PHASE

In the software business, a software product has to be tested thoroughly before being shipped to the client where testing activities can be classified according to their scope. 

Software Testing is the process of checking for bugs and defects, as well as evaluating and verifying that a software product being developed does what it is supposed to do (Functionality). It checks whether the actual software product matches expected requirements, industry standards and passes user acceptance by providing the software product with a set of test inputs (or test cases) and observing if the program behaves as expected thus ensuring that it's defect/bug-free prior to release/launch. 

At a granular level, the purpose of software testing is to identify errors, gaps, or missing requirements and check whether the said software product is defect-free and matches the expected client requirements. If for any reason the software product fails to behave as expected, then the conditions under which failure occurs are noted for later debugging and correction.

Testing is partly conducting system Verification and Validation, collectively known by the acronym V&V where _Verification_ is performed on a system to ensure that the system implements the requirements correctly and _Validation_, to ensures that the requirements properly describe the intended system. 

### SOFTWARE DEPLOYMENT PHASE 

The Software Deployment Phase is where the software product is released by the team for installation to be used by the customer. Deployment needs to be carefully planned most especially when a new software system is going to replace an obsolete system performing business or mission-critical functions. 

In this situation, the goal is to move to the new technology without interrupting business operations and services. 

A standard practice for software projects of this kind makes sure that any change or software evolution does not interfere with production. To achieve this goal, the softwware project team sets up three exact and independent replicas of the same operating environment.

- A **development environment**, where the actual development of the software takes place. The development environment is completely isolated from production, and therefore there is no concern of blocking any critical activity. If data are needed to verify the behavior of the software being developed, a replica of the data in production is used. If there are privacy concerns, like in the case of medical or banking systems, the data on which developers operate are fake or an anonymized version of the data in production. 

- A **testing environment**, where the team tests a system that is ready for deployment. The testing environment is isolated from the development and the production environment, so that, on one hand, no changes made by developers interfere with testing and on the other, testing activities can proceed without any risk of interrupting production. Similar to the production environment, testing activities use replicas of the production data or fake versions. 

- A **production environment**, where the system is actually used. Any change to the production environment interferes (positively or negatively) with the operations for which a system is used. Even if we separate development and testing from production, alas, it is still necessary to ensure a smooth transition of operations when the new system is ready. 

In general, three factors need to be taken into account when deploying a new system, being:
 
1. **The human factor:** are the people ready to use the system?
2. **The data factor:** Is all the data that is needed for the system to run available to the new software?
3. **The hardware factor:** are all interfaces ready and functional? 

The deployment process thus typically requires to perform an assessment of readiness and evaluation of the gaps, which has the goals of understanding the main criticalities and risks. An analysis of documents and interviews with project stakeholders highlights all the critical issues related to the deployment of the new technology. 

This is followed by the selection of a migration strategy, which defines an approach for introducing the new system. 
The following approaches are possible: 

- **Cut-over approach**, which is where the old system is replaced by the new one. 
- **Parallel approach**, which is where the old and new systems operate simultaneously for a period of time to allow the new system to be tested and evaluated before the actual switch takes place. 
- **Pilot approach**, which is where the system is installed for a limited number of users or for a specific business unit. This approach reduces the burden to users (who do not have to live with two systems), while maintaining the complexity of having the old and the new systems both alive. 
- **Phased approach**,which is where functions are rolled out incrementally. 

When the strategy is agreed upon, the final step is the implementation of the release process, which in turn consists of the following steps: 

- The delivery of system training, to ensure that the users acquire the necessary skills to use the new system. This can be done from the testing environment.
- Installing the new system from the development environment to the production.
- Performing a data migration, which includes updating or adding all the data to be used by the new system in the production environment. This is a delicate step, which requires a thorough testing of the migration scripts and a backup of the existing data structures. 
- Set up the support infrastructure, to support operations as the new systems starts being used by the intended users. 

**Note:**

- System training of users in the testing environment and new system installing in the production environment can be done side by side if the teams are big enough to handle them at the same.
- Data migration and the installation of the new system need to be performed contextually. They are typically performed in a period and time where a service can be interrupted and system can be taken off-line without affecting business operations to reduce pressure on the team and risks, should something not go as expected. 

### SOFTWARE PROJECT HANDOVER PHASE

The Software Project handover is the transfer of roles and responsibilities for a software project from one company, team, or person to another. It is a complex process that includes user acceptance testing, deployment, acceptance criteria, post hand-over maintenance, project to mention but a few depending on the client or the team handling the software project.

Even though project handover is an important part of the software product lifecycle, it can be costly or take unpredictable turns unless appropriate precautionary steps are taken.

In cases where the software handover and deployment phases happen at the same time, all stakeholders of the software project are usually present if possible for the hand over after successful deployment. Here the final sign off takes place and the Software product is handed of signaling the end of the project and making way for any post-project activities like support, maintenance and continuous improvement.

### SOFTWARE MAINTENANCE PHASE 

Even though Maintenance occurs throughout the lifecycle of a system, Operations and maintenance consists of the activities to ensure that a software product remains functional after its release. These include:

#### Supporting and Monitoring Operations 

Typically support and maintenance operations are outside the scope of a software project and its something planned and agreed upon by both parties in the software project contract. Many one-off development projects usually plan a support activity after the new system is released to ensure that the software project outputs meet the quality goals and the transition to operations is as smooth as possible. 

The goals of this activity typically include 

- Providing technical support meant to help users get acquainted with the new system and it can be organized as a help-desk collecting tickets from users. Some of these tickets are requests for clarifications on the use of the system and others signaling malfunctions, glitches, and requests for improvement, or triggering maintenance activities.
- System monitoring where a set of metrics are collected on the system after its initial release to monitor performances, issues, and other system features. Information collected can also be used for software project project closure reports.

#### Maintenance 

Maintenance is all about improving the deployed software products’s functionality and can be framed either as a project or operational work often times, posing a dilemma to the software project manager if not properly handled in the software project contractual details.

Every software product continues to evolve after its development and deployment through maintenance efforts. Therefore software maintenance is needed to correct errors, enhance features, port the software to new platforms, etc. 

The four categories(types) of maintenance for software typically include: 

1. **Corrective maintenance**, is performed to fix/correct issues/errors discovered after the release of the system that were not discovered during the product development phase. It is necessary for rectifying the bugs observed while the system(_software product_) is in use.
2. **Preventive maintence**, is typically performed to fix an issues that have been discovered in a software product but haven't yet occurred (or at least signaled by users). 
3. **Adaptive maintenance**, is performed to help adapt a system to changed external conditions. A software product might need maintenance when the customers need the product to run on new platforms, on new operating systems, or when they need the product to interface with new hardware or software. 
4. **Perfective maintenance**, is performed to improve the implementation of the system or enhance its functionalities according to the customer’s requirements. A software product needs maintenance to support the new features that users want it to support, to change different functionalities of the system according to customer demands, or to enhance the performance of the system.

Of these, **_perfective_** and **_corrective_** maintenance are triggered by suggestions and bug reports sent by users often referred to or called issues or tickets. 

#### Organizing Support and Maintenance Activities 

One important aspect of support and maintenance activities is keeping formal track of the tickets. When maintenance is the last activity of a project, software project managers need to consider. 

- How much work has to be allocated, since the software project team will not know in advance how many defects will be signaled. A general strategy is considering the complexity of the system, looking at the outputs of the testing phase, and allocating a percentage of the overall development effort. 
- Distinguishing between tickets that are in the scope of the project (called “nonconformance reports”) and tickets that are outside the scope of a project (called “concessions”). In fact, as users start using the system, they might come out with new ideas and proposals. However, the implementation of these new features is often better framed within the scope of a new project. 

**Note** 
When the planned maintenance period ends, tickets might still arrive. In these situations, organizations and managers are faced with the dilemma of whether the activities should be framed in the context of a new project or not. In some cases, in fact, the amount of work required for the fixes does not justify setting up the machinery of a project.

While there is no silver bullet to decide on the matter, one good practice is to have the team always monitor the time they spend on maintenance activities. This is usually achieved by: 

- Defining a workflow for tickets, which describes how bug reports are formally tracked and managed. Workflows can be very simple or more artic- ulated, if a formal quality control or configuration management process is in place. 

- Automating the collection and management of tickets. This is usually achieved by introducing a bug tracking system. A bug tracking system allows one to maintain a list of tickets and trace their workflow states. Many of these tools also allow one to produce reports and statistics, which can be used by managers to infer information about a system’s quality and about the efficacy of testing activities. 

# SOFTWARE IMPLEMENTATION MANAGEMENT

Software implementation management processes can slightly differ depending on the vendors delivery processes or client agree needs/requirements.

Companies use software implementation when adopting new applications for project management, supply chain management and enterprise resource planning. The process can also apply when a development team updates an existing application.

### A successful software implementation initiative

on the other hand an independent successful software implementation initiative outside the SDLC would typically look like this:

- **Defining the organization's needs:** By defining the organization's needs, you can make it easier to choose from thousands of available applications. Start by considering what you want the software to do. Once you determine the ideal function for the software, consider the organization's additional requirements. It’s also important to consider the software's compatibility with the organization's existing systems and security features among other things.

- **Choosing the appropriate software:** After understanding the organization's needs, you can begin looking for the appropriate software. Try researching the most popular products in your industry and seeing what your competitors use. You might also consider newer products that offer innovative features your organization requires. During your search for the right software, you can read reviews and consult with vendors to ensure the application can manage your team size. You might also ask vendors if they have pilot programs that allow your team to test the software before buying it.

- **sourcing the right vendor:** After choosing the appropriate vendor, and organization can find the right vendors to source this software from based on a number of key factors like working budget, standards, success rate or vendor, timelines, technical capability/proficiency etc.

- **Installing the application:** Vendors offer varying degrees of support with the installation process. Some include this service in the application package, while others charge extra for installation support. If the vendor helps your organization install the new application, consider having them work closely with your IT department. This collaboration can ensure all necessary devices get the application and facilitate seamless integration with existing systems. If your IT department installs the new application independently, try providing the vendor's instructional manual or contact information to troubleshoot potential issues.

- **Configuring features:** Once your IT department installs the application, try having them configure only the most basic features first. Configuring simple features typically involves
using the program's default settings. For instance, you might rely on the program's template customer form before adding additional fields. This process ensures the application is available to employees and clients as soon as possible. By reducing downtime, you can improve productivity and increase customer satisfaction. Keeping the initial configuration process simple also allows you to troubleshoot underlying issues before adding more complicated features.

- **Customizing features:** An application's default settings can help your organization achieve its goals, but you may want to customize features to offer employees and customers more flexibility. For instance, if the program offers a template for a customer form, you can add an address field to collect more relevant information from your customers. Another popular customization option is adding a dashboard to report the company's performance. Productivity metrics can help employees understand their progress and encourage them to meet their goals.

- **Integrating with existing systems:** During the selection process, it's important to choose an application that can integrate with the organization's systems. Compatibility allows multiple features to work together and prevent errors. As your team integrates the new application, they might consider how to transfer data from systems that the organization is no longer using. Automatic data migration can help your team save time while protecting sensitive information, including customer payment details.

- **Training employees:** A good training program can ensure employees understand how to use the new application. The sessions might emphasize how the software differs from old systems and how employees can optimize the various features. As part of the training program, consider providing employees with their account login information and establishing the appropriate permissions.

- **Testing the software:** Employees often report errors they encounter while using new software, but consider formal testing. Application testing allows you to evaluate the effectiveness of each feature and identify bugs that affect multiple users. Your tests can analyze the experience of employees and customers using the program. Once you determine which features require improvement, you can make the appropriate adjustments and conduct more testing. Testing also allows you to identify issues that the vendor is responsible for addressing.

### Software Implementation Challenges

There are some challenges faced by the development team while implementing the software. Some of them are mentioned below:

- Code-reuse - Programming interfaces of present-day languages are very sophisticated and are equipped huge library functions. Still, to bring the cost down of end product, the organization management prefers to re- use the code, which was created earlier for some other software. There are huge issues faced by programmers for compatibility checks and deciding how much code to re-use.
- Version Management - Every time a new software is issued to the customer, developers have to maintain version and configuration related documentation. This documentation needs to be highly accurate and available on time.
- Target-Host - The software program, which is being developed in the organization, needs to be designed for host machines at the customers end. But at times, it is impossible to design a software that works on the target machines.

## CONCLUSION

Project management is the planning, executing, and monitoring of project activities to meet project objectives, achieved by effectively controlling and balancing the constraints of time, cost, and scope, performed through processes and across multiple phases in what is called the project’s “lifecycle”.

Knowledge, skills, goals and personalities are the factors that need to be considered within project management. The project manager and his/her team should collectively possess the necessary and requisite interpersonal and technical skills to facilitate control over the various activities within the project. 

Software development is a complex process involving activities like domain analysis, requirements specification, communication with the customers and end-users, designing and producing different artifacts, adopting new paradigms and technologies, evaluating and testing software products, installing and maintaining the application at the end-user's site, providing customer support, organizing end-user's training, envisioning potential upgrades and negotiating about them with the customers, and many more. 

In order to keep everything under control, eliminate delays, always stay within the budget, and prevent project runaways, i.e. situations in which cost and time exceed what was planned, software project managers must exercise control and guidance over the software development team throughout the software project's lifecycle which in software development is the software development lifecycle.

One of the primary duties of the software project manager of a software development project is to ensure that all of the project activities follow a certain predefined process, i.e. that the activities are organized as a series of actions conducing to a desirable end . The activities are usually organized in distinct phases, and the process specifies what artifacts should be developed and delivered in each phase. For a software development team, conforming to a certain process means complying with an appropriate order of actions or operations. For the project manager, the process provides means for control and guidance of the individual team members and the team as a whole, as it offers criteria for tracing and evaluation of the project's deliverables and activities. 



## GLOSSARY

- **ERP:** Enterprise Resource Planning
- **ERP system:** is an application with a centralized database that can be used to run a company’s entire business. With separate modules for accounting, finance, inventory, human resources, and many more.
- **Disintermediation:** is the process of technology replacing a middleman in a transaction. 
- **Waterfall (software process model):** Way of going about software development and management that is characterized by extensive planning, comprehen- sive documentation, and moving linearly through stages of the software development lifecycle (SDLC).

## REFERENCES & RESOURCES

- [Handbook of Software Engineering Methods by Lara Letaw](https://github.com/setextbook)
- [Software Engineering at Google by Titus Winters , Tom Manshreck , and Hyrum Wright]()
- [Software Project Management](http://www.spmbook.com) 
- [Software Project Management by Adolfo Villafiorita]()
- [Skills of a Successful Software Engineer by FERNANDO DOGLIO](). 

- Information Technology Project Management: Kathy Schwalbe Thomson Publication.
- Information Technology Project Management providing measurable organizational value Jack Marchewka Wiley India.
- Applied software project management Stellman & Greene SPD.
- Software Engineering Project Management by Richard Thayer, Edward Yourdon WILEY INDIA.

## KEYWORDS

``Software``, ``Projects``, ```Software Projects``, ``Software Projects``, ``Project Management``, ``Software Project Management``, ``Software Lifecycle``, ``Software Lifecycle Models``, ``Software Process Models``, ``Process Models``, ``Software Engineering``, ``Software Development``, ``Software Development Lifecycle``, ``The Iron Triangle``, ``Software Implementation``, ``Software Implemenation Management``, ``Software Quality Assurance``, ``Software Testing``, ``Software Deployment``, ``Software Maintenance``, 


